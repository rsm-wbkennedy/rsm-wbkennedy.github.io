---
title: "Forecasting Demand: An Analysis of Different Methods"
author: "Warren Kennedy"
date: today
callout-appearance: minimal # this hides the blue "i" icon on .callout-notes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
```


## Introduction
In this report, we present an analysis of various forecasting methods applied to a dataset containing the demand for eggs from Week 1 to Week 500. We compared four forecasting techniques: Oracle (theoretical maximum profit), Simple Exponential Smoothing (Simple ES), Holt's Linear Trend Method (Holt), and a tuned version of Holt's method (Holt tuned). Our goal was to determine which method provides the best forecast accuracy and profitability.

## Methodology
The Oracle method represents the theoretical maximum possible profit, assuming perfect knowledge of future demand. It serves as a benchmark for comparing other forecasting methods. The profit calculation for the Oracle method uses the actual demand directly, thus providing the upper bound for potential profitability. 

Simple Exponential Smoothing (Simple ES) is a basic forecasting method that uses a smoothing parameter (alpha) to weight the most recent observations. We initially set alpha to 0.2 and calculated forecasts for the dataset. This method helps to smooth out short-term fluctuations and highlight longer-term trends or cycles. Additionally, we calculated the profit using a safety stock based on the forecast errors, ensuring that inventory levels could meet unexpected demand spikes.

Holt's Linear Trend Method (Holt) extends Simple ES by incorporating a trend component, making it suitable for data with a trend. Initially, we used default values for the smoothing parameters (alpha = 0.2, beta = 0.2). This method accounts for both the level of the series and the trend, thus providing a more nuanced forecast than Simple ES. We calculated the forecasts and profits in a manner similar to Simple ES, but with the added benefit of trend adjustment.

To improve the forecast accuracy of Holt's method, we optimized the smoothing parameters (alpha and beta) using a grid search approach to minimize the Mean Squared Error (MSE). By tuning these parameters, we aimed to enhance the method's responsiveness to changes in the data and reduce forecast errors. Using these optimized parameters, we recalculated the forecasts and profits, labeling this version as Holt tuned.

## Results
We compared the average weekly profit from Week 301 to Week 500 for each method. The Oracle method, as expected, provided the highest possible profit since it is based on perfect foresight. Simple ES initially performed well, offering better forecasts than Holt's default settings due to its simplicity and effectiveness in smoothing random variations in the data. However, when we tuned the parameters of Holt's method, it showed a significant improvement in forecast accuracy and profitability, ultimately outperforming Simple ES.

Holt's default settings initially did not provide as high a profit as Simple ES, but after parameter optimization, Holt tuned demonstrated superior performance. This highlights the importance of fine-tuning forecasting models to better capture the underlying patterns in the data.

## Conclusion
The analysis demonstrated that while Simple Exponential Smoothing performed well initially, tuning the parameters of Holt's Linear Trend Method resulted in superior forecasts and higher profitability. This underscores the importance of parameter optimization in forecasting models to achieve the best possible performance. 

By leveraging these findings, organizations can enhance their demand forecasting accuracy and optimize inventory management, leading to improved financial outcomes. Accurate forecasts help in maintaining optimal inventory levels, reducing holding costs, and minimizing stockouts, thereby contributing to overall operational efficiency and customer satisfaction. This study illustrates the practical benefits of applying sophisticated forecasting techniques and the value of continuous improvement through model tuning.

# Appendix

```{r cars}
df <- read.csv("~/MGTA456/Homework/Homework2/forecasting_demand_data_2024.csv")
df <- df[, 1:2]
```

```{r}
# add time trend
df <- df %>%
  mutate(t=row_number()) %>%
  as_tibble()

# descriptives
summary(df)

```

### Including Plots

The data is not normally distributed.

```{r , echo=FALSE}
df %>%
  ggplot(aes(x=demand)) +
  geom_histogram(bins = 50)
```
The demand has shows an upward trend across time. This tells us that a forecast would be best approximated using a moving average based on an appropriate window of time.

```{r}
df %>%
  ggplot(aes(x= t, y= demand)) + 
  geom_line()
```
## Question 1:
Use the data from Week1 to Week300 to estimate the slope “a” in time (t) and the intercept “b” from the linear regression model.

```{r}
# Filter the relevant columns and rows
train <- df[1:300,]

# Perform linear regression
model <- lm(demand ~ t, data = train)

# Get the slope (a) and intercept (b)
a <- coef(model)["t"]
b <- coef(model)["(Intercept)"]

# Print the results
cat("Slope (a):", a, "\n")
cat("Intercept (b):", b, "\n")

```

## Question 2:
Use L0=b and T0=a from the above linear regression. Use alpha=0.2 and beta=0.2. Estimate the forecast from Week1 to Week 500.

```{r}
# Initialize parameters
L0 <- b
T0 <- a
alpha <- 0.2
beta <- 0.2

# Initialize level, trend, and forecast
Lt <- c()
Tt <- c()
Ft <- c()

# Holt-Winters forecasting
for (i in 1:500) {
  if(i == 1) {
    Lt[i] <- alpha * df$demand[i] + (1 - alpha) * (L0 + T0)
    Tt[i] <- beta * (Lt[i] - L0) + (1 - beta) * T0
    Ft[i] <- L0 + T0
  } else if (i <= nrow(df)) {
    Lt[i] <- alpha * df$demand[i] + (1 - alpha) * (Lt[i-1] + Tt[i-1])
    Tt[i] <- beta * (Lt[i] - Lt[i-1]) + (1 - beta) * Tt[i-1]
    Ft[i] <- Lt[i-1] + Tt[i-1]
  } else {
    Lt[i] <- Lt[i-1] + Tt[i-1]
    Tt[i] <- Tt[i-1]
    Ft[i] <- Lt[i-1] + Tt[i-1]
  }
}

# Create a data frame to store the results
forecast_df <- data.frame(Week = 1:500, Forecast = Ft[1:500])

# Print the forecast data
print(forecast_df)

```

## Question 3:
What is the stocking quantity at Week 301?

```{r}
# set exogenous values as constants
price <- 4
cost <- 0.8
salvage <- 0
SL <- (price-cost)/(price-salvage)

# Add the forecast to the dataframe
df <- df %>%
  dplyr::mutate(forecast_Holt = Ft[1:nrow(df)],
                forecast_error_Holt = demand - forecast_Holt)

# Calculate safety stock and stocking quantity for Week 301
safety_stock <- as.numeric(quantile(df$forecast_error_Holt[1:300], SL, na.rm=TRUE))
stocking_optimal_adaptive <- Ft[301] + safety_stock

# Print the stocking quantity at Week 301
cat(sprintf("The stocking quantity at Week 301 is: %.2f", stocking_optimal_adaptive))
```

## Question 4:
What is the weekly average profit from Week301 to Week500? Do you see an improvement over simple Exponential Smoothing?
```{r}
# set placeholder table
profit <- matrix(NA, nrow = nrow(df), ncol = 4)
colnames(profit) <- c("Oracle", "Simple ES", "Holt", "Holt (tuned)")
rownames(profit) <- paste0("day", 1:nrow(df))
head(profit)
```
```{r}
# oracle
# we are assuming we have actual demand
for(i in 301:nrow(df)) {
  profit[i, "Oracle"] <- price*df$demand[i]-cost*df$demand[i]
}
```

```{r}
# Simple ES
L0 <- 2000
alpha <- 0.2
Lt <- c(); Ft <- c()
for (i in 1:nrow(df)) {
  if(i==1) {
    Lt[i] <- alpha*df$demand[i]+(1-alpha)*L0 
    Ft[i] <- L0
  } else {
    Lt[i] <- alpha*df$demand[i]+(1-alpha)*Lt[i-1]
    Ft[i] <- Lt[i-1]
  }
}
df <- df %>%
  dplyr::mutate(forecast_Simple_ES=Ft,
                forecast_error_Simple_ES= demand - forecast_Simple_ES)

# finding safety stock based on TSL
for (i in 301:nrow(df)) {
  safety_stock <- as.numeric(quantile(df$forecast_error_Simple_ES[1:(i-1)],SL,na.rm=TRUE))
  stocking_optimal_adaptive<- df$forecast_Simple_ES[i] + safety_stock
  profit[i,"Simple ES"] <-
    price*min(stocking_optimal_adaptive,df$demand[i]) -
    cost*stocking_optimal_adaptive
}

```


```{r}
# Holt
for (i in 301:nrow(df)) {
  safety_stock <- as.numeric(quantile(df$forecast_error_Holt[1:(i-1)], SL, na.rm=TRUE))
  stocking_optimal_adaptive <- df$forecast_Holt[i] + safety_stock
  profit[i, "Holt"] <-
    price * min(stocking_optimal_adaptive, df$demand[i]) -
    cost * stocking_optimal_adaptive
}

average_profit <- mean(profit[301:500, "Holt"], na.rm=TRUE)

# Print the weekly average profit
cat(sprintf("The weekly average profit from Week 301 to Week 500 is: %.2f", average_profit))
```
**When we calculate the average profit for a Simple Exponential Smoothing and our Holt model, we observe that the Holt model does not offer an improvement over the Simple ES.**
```{r}
# compare average profit by forecasting method
apply(profit[301:500, ], 2, mean)
```

## Question 5
Use the data from Week1 to Week300 to find an “optimal” alpha and beta values.

```{r}
# Function to calculate MSE for given alpha and beta
mse_holt <- function(params, predict_from, predict_to, df, L0, T0) {
  alpha <- params[1]
  beta <- params[2]
  
  df_predict <- df %>%
    dplyr::slice(predict_from:predict_to)
  df_true <- df %>%
    dplyr::slice(predict_from:predict_to)
  
  Lt <- c()
  Tt <- c()
  Ft <- c()
  n <- predict_to - predict_from + 1
  
  for (i in 1:n) {
    if(i == 1) {
      Lt[i] <- alpha * df_predict$demand[i] + (1 - alpha) * (L0 + T0)
      Tt[i] <- beta * (Lt[i] - L0) + (1 - beta) * T0
      Ft[i] <- L0 + T0
    } else {
      Lt[i] <- alpha * df_predict$demand[i] + (1 - alpha) * (Lt[i-1] + Tt[i-1])
      Tt[i] <- beta * (Lt[i] - Lt[i-1]) + (1 - beta) * Tt[i-1]
      Ft[i] <- Lt[i-1] + Tt[i-1]
    }
  }
  
  mse <- sum((df_true$demand - Ft)^2) / n
  return(mse)
}
```

```{r}
# Check the initial MSE value
initial_mse <- mse_holt(c(0.2, 0.2), 1, 300, df, L0, T0)
cat(sprintf("The initial MSE is: %.2f\n", initial_mse))
```


```{r}
# Optimizing alpha and beta using the optim function
res <- optim(
  par = c(0.2, 0.2), 
  fn = mse_holt, 
  method = "L-BFGS-B",
  predict_from = 1,
  predict_to = 300,
  df = df,
  L0 = L0,
  T0 = T0,
  lower = c(0.01,0.0),
  upper=c(1,1),
  control = list(maxit = 1000)
)

res
```
```{r}
  # Extract optimal alpha and beta
  optimal_alpha <- res$par[1]
  optimal_beta <- res$par[2]
  
  # Print the optimal alpha and beta values
  cat(sprintf("The optimal alpha is: %.2f\n", optimal_alpha))
  cat(sprintf("The optimal beta is: %.2f\n", optimal_beta))
```
## Question 6:
Use alpha and beta values from Question 5, and repeat Question 4.
```{r}
# Initialize level, trend, and forecast for Holt-Winters with optimal parameters
Lt <- c(); Tt <- c(); Ft <- c()

# Holt-Winters forecasting with optimal parameters
for (i in 1:500) {
  if(i == 1) {
    Lt[i] <- optimal_alpha * df$demand[i] + (1 - optimal_alpha) * (L0 + T0)
    Tt[i] <- optimal_beta * (Lt[i] - L0) + (1 - optimal_beta) * T0
    Ft[i] <- L0 + T0
  } else if (i <= nrow(df)) {
    Lt[i] <- optimal_alpha * df$demand[i] + (1 - optimal_alpha) * (Lt[i-1] + Tt[i-1])
    Tt[i] <- optimal_beta * (Lt[i] - Lt[i-1]) + (1 - optimal_beta) * Tt[i-1]
    Ft[i] <- Lt[i-1] + Tt[i-1]
  } else {
    Lt[i] <- Lt[i-1] + Tt[i-1]
    Tt[i] <- Tt[i-1]
    Ft[i] <- Lt[i-1] + Tt[i-1]
  }
}

# Add the forecast to the dataframe
df <- df %>%
  dplyr::mutate(forecast_Holt_tuned = Ft[1:nrow(df)],
                forecast_error_Holt_tuned = demand - forecast_Holt_tuned)

# Calculate Holt-Winters profit with optimal parameters
for (i in 301:nrow(df)) {
  safety_stock <- as.numeric(quantile(df$forecast_error_Holt_tuned[1:(i-1)], SL, na.rm=TRUE))
  stocking_optimal_adaptive <- df$forecast_Holt_tuned[i] + safety_stock
  profit[i, "Holt (tuned)"] <- price * min(stocking_optimal_adaptive, df$demand[i]) - cost * stocking_optimal_adaptive
}

# Compare average profit by forecasting method
average_profits <- apply(profit[301:500, ], 2, mean, na.rm=TRUE)
print(average_profits)

```

